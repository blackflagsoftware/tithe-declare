// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v5.29.3
// source: pkg/proto/tithe-declare.proto

package protobuf

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	RoleService_GetRole_FullMethodName    = "/proto.RoleService/GetRole"
	RoleService_SearchRole_FullMethodName = "/proto.RoleService/SearchRole"
	RoleService_CreateRole_FullMethodName = "/proto.RoleService/CreateRole"
	RoleService_UpdateRole_FullMethodName = "/proto.RoleService/UpdateRole"
	RoleService_DeleteRole_FullMethodName = "/proto.RoleService/DeleteRole"
)

// RoleServiceClient is the client API for RoleService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type RoleServiceClient interface {
	GetRole(ctx context.Context, in *RoleIDIn, opts ...grpc.CallOption) (*RoleResponse, error)
	SearchRole(ctx context.Context, in *Role, opts ...grpc.CallOption) (*RoleRepeatResponse, error)
	CreateRole(ctx context.Context, in *Role, opts ...grpc.CallOption) (*RoleResponse, error)
	UpdateRole(ctx context.Context, in *Role, opts ...grpc.CallOption) (*Result, error)
	DeleteRole(ctx context.Context, in *RoleIDIn, opts ...grpc.CallOption) (*Result, error)
}

type roleServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewRoleServiceClient(cc grpc.ClientConnInterface) RoleServiceClient {
	return &roleServiceClient{cc}
}

func (c *roleServiceClient) GetRole(ctx context.Context, in *RoleIDIn, opts ...grpc.CallOption) (*RoleResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RoleResponse)
	err := c.cc.Invoke(ctx, RoleService_GetRole_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *roleServiceClient) SearchRole(ctx context.Context, in *Role, opts ...grpc.CallOption) (*RoleRepeatResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RoleRepeatResponse)
	err := c.cc.Invoke(ctx, RoleService_SearchRole_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *roleServiceClient) CreateRole(ctx context.Context, in *Role, opts ...grpc.CallOption) (*RoleResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RoleResponse)
	err := c.cc.Invoke(ctx, RoleService_CreateRole_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *roleServiceClient) UpdateRole(ctx context.Context, in *Role, opts ...grpc.CallOption) (*Result, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Result)
	err := c.cc.Invoke(ctx, RoleService_UpdateRole_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *roleServiceClient) DeleteRole(ctx context.Context, in *RoleIDIn, opts ...grpc.CallOption) (*Result, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Result)
	err := c.cc.Invoke(ctx, RoleService_DeleteRole_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RoleServiceServer is the server API for RoleService service.
// All implementations must embed UnimplementedRoleServiceServer
// for forward compatibility.
type RoleServiceServer interface {
	GetRole(context.Context, *RoleIDIn) (*RoleResponse, error)
	SearchRole(context.Context, *Role) (*RoleRepeatResponse, error)
	CreateRole(context.Context, *Role) (*RoleResponse, error)
	UpdateRole(context.Context, *Role) (*Result, error)
	DeleteRole(context.Context, *RoleIDIn) (*Result, error)
	mustEmbedUnimplementedRoleServiceServer()
}

// UnimplementedRoleServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedRoleServiceServer struct{}

func (UnimplementedRoleServiceServer) GetRole(context.Context, *RoleIDIn) (*RoleResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetRole not implemented")
}
func (UnimplementedRoleServiceServer) SearchRole(context.Context, *Role) (*RoleRepeatResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SearchRole not implemented")
}
func (UnimplementedRoleServiceServer) CreateRole(context.Context, *Role) (*RoleResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateRole not implemented")
}
func (UnimplementedRoleServiceServer) UpdateRole(context.Context, *Role) (*Result, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateRole not implemented")
}
func (UnimplementedRoleServiceServer) DeleteRole(context.Context, *RoleIDIn) (*Result, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteRole not implemented")
}
func (UnimplementedRoleServiceServer) mustEmbedUnimplementedRoleServiceServer() {}
func (UnimplementedRoleServiceServer) testEmbeddedByValue()                     {}

// UnsafeRoleServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to RoleServiceServer will
// result in compilation errors.
type UnsafeRoleServiceServer interface {
	mustEmbedUnimplementedRoleServiceServer()
}

func RegisterRoleServiceServer(s grpc.ServiceRegistrar, srv RoleServiceServer) {
	// If the following call pancis, it indicates UnimplementedRoleServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&RoleService_ServiceDesc, srv)
}

func _RoleService_GetRole_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RoleIDIn)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoleServiceServer).GetRole(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RoleService_GetRole_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoleServiceServer).GetRole(ctx, req.(*RoleIDIn))
	}
	return interceptor(ctx, in, info, handler)
}

func _RoleService_SearchRole_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Role)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoleServiceServer).SearchRole(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RoleService_SearchRole_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoleServiceServer).SearchRole(ctx, req.(*Role))
	}
	return interceptor(ctx, in, info, handler)
}

func _RoleService_CreateRole_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Role)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoleServiceServer).CreateRole(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RoleService_CreateRole_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoleServiceServer).CreateRole(ctx, req.(*Role))
	}
	return interceptor(ctx, in, info, handler)
}

func _RoleService_UpdateRole_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Role)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoleServiceServer).UpdateRole(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RoleService_UpdateRole_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoleServiceServer).UpdateRole(ctx, req.(*Role))
	}
	return interceptor(ctx, in, info, handler)
}

func _RoleService_DeleteRole_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RoleIDIn)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoleServiceServer).DeleteRole(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RoleService_DeleteRole_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoleServiceServer).DeleteRole(ctx, req.(*RoleIDIn))
	}
	return interceptor(ctx, in, info, handler)
}

// RoleService_ServiceDesc is the grpc.ServiceDesc for RoleService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var RoleService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "proto.RoleService",
	HandlerType: (*RoleServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetRole",
			Handler:    _RoleService_GetRole_Handler,
		},
		{
			MethodName: "SearchRole",
			Handler:    _RoleService_SearchRole_Handler,
		},
		{
			MethodName: "CreateRole",
			Handler:    _RoleService_CreateRole_Handler,
		},
		{
			MethodName: "UpdateRole",
			Handler:    _RoleService_UpdateRole_Handler,
		},
		{
			MethodName: "DeleteRole",
			Handler:    _RoleService_DeleteRole_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "pkg/proto/tithe-declare.proto",
}

const (
	LoginService_GetLogin_FullMethodName    = "/proto.LoginService/GetLogin"
	LoginService_SearchLogin_FullMethodName = "/proto.LoginService/SearchLogin"
	LoginService_CreateLogin_FullMethodName = "/proto.LoginService/CreateLogin"
	LoginService_UpdateLogin_FullMethodName = "/proto.LoginService/UpdateLogin"
	LoginService_DeleteLogin_FullMethodName = "/proto.LoginService/DeleteLogin"
)

// LoginServiceClient is the client API for LoginService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type LoginServiceClient interface {
	GetLogin(ctx context.Context, in *LoginIDIn, opts ...grpc.CallOption) (*LoginResponse, error)
	SearchLogin(ctx context.Context, in *Login, opts ...grpc.CallOption) (*LoginRepeatResponse, error)
	CreateLogin(ctx context.Context, in *Login, opts ...grpc.CallOption) (*LoginResponse, error)
	UpdateLogin(ctx context.Context, in *Login, opts ...grpc.CallOption) (*Result, error)
	DeleteLogin(ctx context.Context, in *LoginIDIn, opts ...grpc.CallOption) (*Result, error)
}

type loginServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewLoginServiceClient(cc grpc.ClientConnInterface) LoginServiceClient {
	return &loginServiceClient{cc}
}

func (c *loginServiceClient) GetLogin(ctx context.Context, in *LoginIDIn, opts ...grpc.CallOption) (*LoginResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(LoginResponse)
	err := c.cc.Invoke(ctx, LoginService_GetLogin_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *loginServiceClient) SearchLogin(ctx context.Context, in *Login, opts ...grpc.CallOption) (*LoginRepeatResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(LoginRepeatResponse)
	err := c.cc.Invoke(ctx, LoginService_SearchLogin_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *loginServiceClient) CreateLogin(ctx context.Context, in *Login, opts ...grpc.CallOption) (*LoginResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(LoginResponse)
	err := c.cc.Invoke(ctx, LoginService_CreateLogin_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *loginServiceClient) UpdateLogin(ctx context.Context, in *Login, opts ...grpc.CallOption) (*Result, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Result)
	err := c.cc.Invoke(ctx, LoginService_UpdateLogin_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *loginServiceClient) DeleteLogin(ctx context.Context, in *LoginIDIn, opts ...grpc.CallOption) (*Result, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Result)
	err := c.cc.Invoke(ctx, LoginService_DeleteLogin_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// LoginServiceServer is the server API for LoginService service.
// All implementations must embed UnimplementedLoginServiceServer
// for forward compatibility.
type LoginServiceServer interface {
	GetLogin(context.Context, *LoginIDIn) (*LoginResponse, error)
	SearchLogin(context.Context, *Login) (*LoginRepeatResponse, error)
	CreateLogin(context.Context, *Login) (*LoginResponse, error)
	UpdateLogin(context.Context, *Login) (*Result, error)
	DeleteLogin(context.Context, *LoginIDIn) (*Result, error)
	mustEmbedUnimplementedLoginServiceServer()
}

// UnimplementedLoginServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedLoginServiceServer struct{}

func (UnimplementedLoginServiceServer) GetLogin(context.Context, *LoginIDIn) (*LoginResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetLogin not implemented")
}
func (UnimplementedLoginServiceServer) SearchLogin(context.Context, *Login) (*LoginRepeatResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SearchLogin not implemented")
}
func (UnimplementedLoginServiceServer) CreateLogin(context.Context, *Login) (*LoginResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateLogin not implemented")
}
func (UnimplementedLoginServiceServer) UpdateLogin(context.Context, *Login) (*Result, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateLogin not implemented")
}
func (UnimplementedLoginServiceServer) DeleteLogin(context.Context, *LoginIDIn) (*Result, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteLogin not implemented")
}
func (UnimplementedLoginServiceServer) mustEmbedUnimplementedLoginServiceServer() {}
func (UnimplementedLoginServiceServer) testEmbeddedByValue()                      {}

// UnsafeLoginServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to LoginServiceServer will
// result in compilation errors.
type UnsafeLoginServiceServer interface {
	mustEmbedUnimplementedLoginServiceServer()
}

func RegisterLoginServiceServer(s grpc.ServiceRegistrar, srv LoginServiceServer) {
	// If the following call pancis, it indicates UnimplementedLoginServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&LoginService_ServiceDesc, srv)
}

func _LoginService_GetLogin_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LoginIDIn)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LoginServiceServer).GetLogin(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LoginService_GetLogin_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LoginServiceServer).GetLogin(ctx, req.(*LoginIDIn))
	}
	return interceptor(ctx, in, info, handler)
}

func _LoginService_SearchLogin_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Login)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LoginServiceServer).SearchLogin(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LoginService_SearchLogin_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LoginServiceServer).SearchLogin(ctx, req.(*Login))
	}
	return interceptor(ctx, in, info, handler)
}

func _LoginService_CreateLogin_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Login)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LoginServiceServer).CreateLogin(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LoginService_CreateLogin_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LoginServiceServer).CreateLogin(ctx, req.(*Login))
	}
	return interceptor(ctx, in, info, handler)
}

func _LoginService_UpdateLogin_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Login)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LoginServiceServer).UpdateLogin(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LoginService_UpdateLogin_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LoginServiceServer).UpdateLogin(ctx, req.(*Login))
	}
	return interceptor(ctx, in, info, handler)
}

func _LoginService_DeleteLogin_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LoginIDIn)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LoginServiceServer).DeleteLogin(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LoginService_DeleteLogin_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LoginServiceServer).DeleteLogin(ctx, req.(*LoginIDIn))
	}
	return interceptor(ctx, in, info, handler)
}

// LoginService_ServiceDesc is the grpc.ServiceDesc for LoginService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var LoginService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "proto.LoginService",
	HandlerType: (*LoginServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetLogin",
			Handler:    _LoginService_GetLogin_Handler,
		},
		{
			MethodName: "SearchLogin",
			Handler:    _LoginService_SearchLogin_Handler,
		},
		{
			MethodName: "CreateLogin",
			Handler:    _LoginService_CreateLogin_Handler,
		},
		{
			MethodName: "UpdateLogin",
			Handler:    _LoginService_UpdateLogin_Handler,
		},
		{
			MethodName: "DeleteLogin",
			Handler:    _LoginService_DeleteLogin_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "pkg/proto/tithe-declare.proto",
}

const (
	LoginRoleService_GetLoginRole_FullMethodName    = "/proto.LoginRoleService/GetLoginRole"
	LoginRoleService_SearchLoginRole_FullMethodName = "/proto.LoginRoleService/SearchLoginRole"
	LoginRoleService_CreateLoginRole_FullMethodName = "/proto.LoginRoleService/CreateLoginRole"
	LoginRoleService_BulkLoginRole_FullMethodName   = "/proto.LoginRoleService/BulkLoginRole"
	LoginRoleService_UpdateLoginRole_FullMethodName = "/proto.LoginRoleService/UpdateLoginRole"
	LoginRoleService_DeleteLoginRole_FullMethodName = "/proto.LoginRoleService/DeleteLoginRole"
)

// LoginRoleServiceClient is the client API for LoginRoleService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type LoginRoleServiceClient interface {
	GetLoginRole(ctx context.Context, in *LoginRoleIDIn, opts ...grpc.CallOption) (*LoginRoleResponse, error)
	SearchLoginRole(ctx context.Context, in *LoginRole, opts ...grpc.CallOption) (*LoginRoleRepeatResponse, error)
	CreateLoginRole(ctx context.Context, in *LoginRole, opts ...grpc.CallOption) (*LoginRoleResponse, error)
	BulkLoginRole(ctx context.Context, in *LoginRoleUpdate, opts ...grpc.CallOption) (*LoginRoleUpdateResponse, error)
	UpdateLoginRole(ctx context.Context, in *LoginRole, opts ...grpc.CallOption) (*Result, error)
	DeleteLoginRole(ctx context.Context, in *LoginRoleIDIn, opts ...grpc.CallOption) (*Result, error)
}

type loginRoleServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewLoginRoleServiceClient(cc grpc.ClientConnInterface) LoginRoleServiceClient {
	return &loginRoleServiceClient{cc}
}

func (c *loginRoleServiceClient) GetLoginRole(ctx context.Context, in *LoginRoleIDIn, opts ...grpc.CallOption) (*LoginRoleResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(LoginRoleResponse)
	err := c.cc.Invoke(ctx, LoginRoleService_GetLoginRole_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *loginRoleServiceClient) SearchLoginRole(ctx context.Context, in *LoginRole, opts ...grpc.CallOption) (*LoginRoleRepeatResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(LoginRoleRepeatResponse)
	err := c.cc.Invoke(ctx, LoginRoleService_SearchLoginRole_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *loginRoleServiceClient) CreateLoginRole(ctx context.Context, in *LoginRole, opts ...grpc.CallOption) (*LoginRoleResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(LoginRoleResponse)
	err := c.cc.Invoke(ctx, LoginRoleService_CreateLoginRole_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *loginRoleServiceClient) BulkLoginRole(ctx context.Context, in *LoginRoleUpdate, opts ...grpc.CallOption) (*LoginRoleUpdateResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(LoginRoleUpdateResponse)
	err := c.cc.Invoke(ctx, LoginRoleService_BulkLoginRole_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *loginRoleServiceClient) UpdateLoginRole(ctx context.Context, in *LoginRole, opts ...grpc.CallOption) (*Result, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Result)
	err := c.cc.Invoke(ctx, LoginRoleService_UpdateLoginRole_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *loginRoleServiceClient) DeleteLoginRole(ctx context.Context, in *LoginRoleIDIn, opts ...grpc.CallOption) (*Result, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Result)
	err := c.cc.Invoke(ctx, LoginRoleService_DeleteLoginRole_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// LoginRoleServiceServer is the server API for LoginRoleService service.
// All implementations must embed UnimplementedLoginRoleServiceServer
// for forward compatibility.
type LoginRoleServiceServer interface {
	GetLoginRole(context.Context, *LoginRoleIDIn) (*LoginRoleResponse, error)
	SearchLoginRole(context.Context, *LoginRole) (*LoginRoleRepeatResponse, error)
	CreateLoginRole(context.Context, *LoginRole) (*LoginRoleResponse, error)
	BulkLoginRole(context.Context, *LoginRoleUpdate) (*LoginRoleUpdateResponse, error)
	UpdateLoginRole(context.Context, *LoginRole) (*Result, error)
	DeleteLoginRole(context.Context, *LoginRoleIDIn) (*Result, error)
	mustEmbedUnimplementedLoginRoleServiceServer()
}

// UnimplementedLoginRoleServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedLoginRoleServiceServer struct{}

func (UnimplementedLoginRoleServiceServer) GetLoginRole(context.Context, *LoginRoleIDIn) (*LoginRoleResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetLoginRole not implemented")
}
func (UnimplementedLoginRoleServiceServer) SearchLoginRole(context.Context, *LoginRole) (*LoginRoleRepeatResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SearchLoginRole not implemented")
}
func (UnimplementedLoginRoleServiceServer) CreateLoginRole(context.Context, *LoginRole) (*LoginRoleResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateLoginRole not implemented")
}
func (UnimplementedLoginRoleServiceServer) BulkLoginRole(context.Context, *LoginRoleUpdate) (*LoginRoleUpdateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BulkLoginRole not implemented")
}
func (UnimplementedLoginRoleServiceServer) UpdateLoginRole(context.Context, *LoginRole) (*Result, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateLoginRole not implemented")
}
func (UnimplementedLoginRoleServiceServer) DeleteLoginRole(context.Context, *LoginRoleIDIn) (*Result, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteLoginRole not implemented")
}
func (UnimplementedLoginRoleServiceServer) mustEmbedUnimplementedLoginRoleServiceServer() {}
func (UnimplementedLoginRoleServiceServer) testEmbeddedByValue()                          {}

// UnsafeLoginRoleServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to LoginRoleServiceServer will
// result in compilation errors.
type UnsafeLoginRoleServiceServer interface {
	mustEmbedUnimplementedLoginRoleServiceServer()
}

func RegisterLoginRoleServiceServer(s grpc.ServiceRegistrar, srv LoginRoleServiceServer) {
	// If the following call pancis, it indicates UnimplementedLoginRoleServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&LoginRoleService_ServiceDesc, srv)
}

func _LoginRoleService_GetLoginRole_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LoginRoleIDIn)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LoginRoleServiceServer).GetLoginRole(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LoginRoleService_GetLoginRole_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LoginRoleServiceServer).GetLoginRole(ctx, req.(*LoginRoleIDIn))
	}
	return interceptor(ctx, in, info, handler)
}

func _LoginRoleService_SearchLoginRole_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LoginRole)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LoginRoleServiceServer).SearchLoginRole(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LoginRoleService_SearchLoginRole_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LoginRoleServiceServer).SearchLoginRole(ctx, req.(*LoginRole))
	}
	return interceptor(ctx, in, info, handler)
}

func _LoginRoleService_CreateLoginRole_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LoginRole)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LoginRoleServiceServer).CreateLoginRole(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LoginRoleService_CreateLoginRole_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LoginRoleServiceServer).CreateLoginRole(ctx, req.(*LoginRole))
	}
	return interceptor(ctx, in, info, handler)
}

func _LoginRoleService_BulkLoginRole_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LoginRoleUpdate)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LoginRoleServiceServer).BulkLoginRole(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LoginRoleService_BulkLoginRole_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LoginRoleServiceServer).BulkLoginRole(ctx, req.(*LoginRoleUpdate))
	}
	return interceptor(ctx, in, info, handler)
}

func _LoginRoleService_UpdateLoginRole_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LoginRole)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LoginRoleServiceServer).UpdateLoginRole(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LoginRoleService_UpdateLoginRole_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LoginRoleServiceServer).UpdateLoginRole(ctx, req.(*LoginRole))
	}
	return interceptor(ctx, in, info, handler)
}

func _LoginRoleService_DeleteLoginRole_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LoginRoleIDIn)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LoginRoleServiceServer).DeleteLoginRole(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LoginRoleService_DeleteLoginRole_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LoginRoleServiceServer).DeleteLoginRole(ctx, req.(*LoginRoleIDIn))
	}
	return interceptor(ctx, in, info, handler)
}

// LoginRoleService_ServiceDesc is the grpc.ServiceDesc for LoginRoleService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var LoginRoleService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "proto.LoginRoleService",
	HandlerType: (*LoginRoleServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetLoginRole",
			Handler:    _LoginRoleService_GetLoginRole_Handler,
		},
		{
			MethodName: "SearchLoginRole",
			Handler:    _LoginRoleService_SearchLoginRole_Handler,
		},
		{
			MethodName: "CreateLoginRole",
			Handler:    _LoginRoleService_CreateLoginRole_Handler,
		},
		{
			MethodName: "BulkLoginRole",
			Handler:    _LoginRoleService_BulkLoginRole_Handler,
		},
		{
			MethodName: "UpdateLoginRole",
			Handler:    _LoginRoleService_UpdateLoginRole_Handler,
		},
		{
			MethodName: "DeleteLoginRole",
			Handler:    _LoginRoleService_DeleteLoginRole_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "pkg/proto/tithe-declare.proto",
}

const (
	TdDateService_GetTdDate_FullMethodName    = "/proto.TdDateService/GetTdDate"
	TdDateService_SearchTdDate_FullMethodName = "/proto.TdDateService/SearchTdDate"
	TdDateService_CreateTdDate_FullMethodName = "/proto.TdDateService/CreateTdDate"
	TdDateService_UpdateTdDate_FullMethodName = "/proto.TdDateService/UpdateTdDate"
	TdDateService_DeleteTdDate_FullMethodName = "/proto.TdDateService/DeleteTdDate"
)

// TdDateServiceClient is the client API for TdDateService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type TdDateServiceClient interface {
	GetTdDate(ctx context.Context, in *TdDateIDIn, opts ...grpc.CallOption) (*TdDateResponse, error)
	SearchTdDate(ctx context.Context, in *TdDate, opts ...grpc.CallOption) (*TdDateRepeatResponse, error)
	CreateTdDate(ctx context.Context, in *TdDate, opts ...grpc.CallOption) (*TdDateResponse, error)
	UpdateTdDate(ctx context.Context, in *TdDate, opts ...grpc.CallOption) (*Result, error)
	DeleteTdDate(ctx context.Context, in *TdDateIDIn, opts ...grpc.CallOption) (*Result, error)
}

type tdDateServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewTdDateServiceClient(cc grpc.ClientConnInterface) TdDateServiceClient {
	return &tdDateServiceClient{cc}
}

func (c *tdDateServiceClient) GetTdDate(ctx context.Context, in *TdDateIDIn, opts ...grpc.CallOption) (*TdDateResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TdDateResponse)
	err := c.cc.Invoke(ctx, TdDateService_GetTdDate_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tdDateServiceClient) SearchTdDate(ctx context.Context, in *TdDate, opts ...grpc.CallOption) (*TdDateRepeatResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TdDateRepeatResponse)
	err := c.cc.Invoke(ctx, TdDateService_SearchTdDate_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tdDateServiceClient) CreateTdDate(ctx context.Context, in *TdDate, opts ...grpc.CallOption) (*TdDateResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TdDateResponse)
	err := c.cc.Invoke(ctx, TdDateService_CreateTdDate_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tdDateServiceClient) UpdateTdDate(ctx context.Context, in *TdDate, opts ...grpc.CallOption) (*Result, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Result)
	err := c.cc.Invoke(ctx, TdDateService_UpdateTdDate_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tdDateServiceClient) DeleteTdDate(ctx context.Context, in *TdDateIDIn, opts ...grpc.CallOption) (*Result, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Result)
	err := c.cc.Invoke(ctx, TdDateService_DeleteTdDate_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// TdDateServiceServer is the server API for TdDateService service.
// All implementations must embed UnimplementedTdDateServiceServer
// for forward compatibility.
type TdDateServiceServer interface {
	GetTdDate(context.Context, *TdDateIDIn) (*TdDateResponse, error)
	SearchTdDate(context.Context, *TdDate) (*TdDateRepeatResponse, error)
	CreateTdDate(context.Context, *TdDate) (*TdDateResponse, error)
	UpdateTdDate(context.Context, *TdDate) (*Result, error)
	DeleteTdDate(context.Context, *TdDateIDIn) (*Result, error)
	mustEmbedUnimplementedTdDateServiceServer()
}

// UnimplementedTdDateServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedTdDateServiceServer struct{}

func (UnimplementedTdDateServiceServer) GetTdDate(context.Context, *TdDateIDIn) (*TdDateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTdDate not implemented")
}
func (UnimplementedTdDateServiceServer) SearchTdDate(context.Context, *TdDate) (*TdDateRepeatResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SearchTdDate not implemented")
}
func (UnimplementedTdDateServiceServer) CreateTdDate(context.Context, *TdDate) (*TdDateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateTdDate not implemented")
}
func (UnimplementedTdDateServiceServer) UpdateTdDate(context.Context, *TdDate) (*Result, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateTdDate not implemented")
}
func (UnimplementedTdDateServiceServer) DeleteTdDate(context.Context, *TdDateIDIn) (*Result, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteTdDate not implemented")
}
func (UnimplementedTdDateServiceServer) mustEmbedUnimplementedTdDateServiceServer() {}
func (UnimplementedTdDateServiceServer) testEmbeddedByValue()                       {}

// UnsafeTdDateServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to TdDateServiceServer will
// result in compilation errors.
type UnsafeTdDateServiceServer interface {
	mustEmbedUnimplementedTdDateServiceServer()
}

func RegisterTdDateServiceServer(s grpc.ServiceRegistrar, srv TdDateServiceServer) {
	// If the following call pancis, it indicates UnimplementedTdDateServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&TdDateService_ServiceDesc, srv)
}

func _TdDateService_GetTdDate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TdDateIDIn)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TdDateServiceServer).GetTdDate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TdDateService_GetTdDate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TdDateServiceServer).GetTdDate(ctx, req.(*TdDateIDIn))
	}
	return interceptor(ctx, in, info, handler)
}

func _TdDateService_SearchTdDate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TdDate)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TdDateServiceServer).SearchTdDate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TdDateService_SearchTdDate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TdDateServiceServer).SearchTdDate(ctx, req.(*TdDate))
	}
	return interceptor(ctx, in, info, handler)
}

func _TdDateService_CreateTdDate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TdDate)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TdDateServiceServer).CreateTdDate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TdDateService_CreateTdDate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TdDateServiceServer).CreateTdDate(ctx, req.(*TdDate))
	}
	return interceptor(ctx, in, info, handler)
}

func _TdDateService_UpdateTdDate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TdDate)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TdDateServiceServer).UpdateTdDate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TdDateService_UpdateTdDate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TdDateServiceServer).UpdateTdDate(ctx, req.(*TdDate))
	}
	return interceptor(ctx, in, info, handler)
}

func _TdDateService_DeleteTdDate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TdDateIDIn)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TdDateServiceServer).DeleteTdDate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TdDateService_DeleteTdDate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TdDateServiceServer).DeleteTdDate(ctx, req.(*TdDateIDIn))
	}
	return interceptor(ctx, in, info, handler)
}

// TdDateService_ServiceDesc is the grpc.ServiceDesc for TdDateService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var TdDateService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "proto.TdDateService",
	HandlerType: (*TdDateServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetTdDate",
			Handler:    _TdDateService_GetTdDate_Handler,
		},
		{
			MethodName: "SearchTdDate",
			Handler:    _TdDateService_SearchTdDate_Handler,
		},
		{
			MethodName: "CreateTdDate",
			Handler:    _TdDateService_CreateTdDate_Handler,
		},
		{
			MethodName: "UpdateTdDate",
			Handler:    _TdDateService_UpdateTdDate_Handler,
		},
		{
			MethodName: "DeleteTdDate",
			Handler:    _TdDateService_DeleteTdDate_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "pkg/proto/tithe-declare.proto",
}

const (
	EmailReminderService_GetEmailReminder_FullMethodName    = "/proto.EmailReminderService/GetEmailReminder"
	EmailReminderService_SearchEmailReminder_FullMethodName = "/proto.EmailReminderService/SearchEmailReminder"
	EmailReminderService_CreateEmailReminder_FullMethodName = "/proto.EmailReminderService/CreateEmailReminder"
	EmailReminderService_UpdateEmailReminder_FullMethodName = "/proto.EmailReminderService/UpdateEmailReminder"
	EmailReminderService_DeleteEmailReminder_FullMethodName = "/proto.EmailReminderService/DeleteEmailReminder"
)

// EmailReminderServiceClient is the client API for EmailReminderService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type EmailReminderServiceClient interface {
	GetEmailReminder(ctx context.Context, in *EmailReminderIDIn, opts ...grpc.CallOption) (*EmailReminderResponse, error)
	SearchEmailReminder(ctx context.Context, in *EmailReminder, opts ...grpc.CallOption) (*EmailReminderRepeatResponse, error)
	CreateEmailReminder(ctx context.Context, in *EmailReminder, opts ...grpc.CallOption) (*EmailReminderResponse, error)
	UpdateEmailReminder(ctx context.Context, in *EmailReminder, opts ...grpc.CallOption) (*Result, error)
	DeleteEmailReminder(ctx context.Context, in *EmailReminderIDIn, opts ...grpc.CallOption) (*Result, error)
}

type emailReminderServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewEmailReminderServiceClient(cc grpc.ClientConnInterface) EmailReminderServiceClient {
	return &emailReminderServiceClient{cc}
}

func (c *emailReminderServiceClient) GetEmailReminder(ctx context.Context, in *EmailReminderIDIn, opts ...grpc.CallOption) (*EmailReminderResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EmailReminderResponse)
	err := c.cc.Invoke(ctx, EmailReminderService_GetEmailReminder_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *emailReminderServiceClient) SearchEmailReminder(ctx context.Context, in *EmailReminder, opts ...grpc.CallOption) (*EmailReminderRepeatResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EmailReminderRepeatResponse)
	err := c.cc.Invoke(ctx, EmailReminderService_SearchEmailReminder_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *emailReminderServiceClient) CreateEmailReminder(ctx context.Context, in *EmailReminder, opts ...grpc.CallOption) (*EmailReminderResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EmailReminderResponse)
	err := c.cc.Invoke(ctx, EmailReminderService_CreateEmailReminder_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *emailReminderServiceClient) UpdateEmailReminder(ctx context.Context, in *EmailReminder, opts ...grpc.CallOption) (*Result, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Result)
	err := c.cc.Invoke(ctx, EmailReminderService_UpdateEmailReminder_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *emailReminderServiceClient) DeleteEmailReminder(ctx context.Context, in *EmailReminderIDIn, opts ...grpc.CallOption) (*Result, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Result)
	err := c.cc.Invoke(ctx, EmailReminderService_DeleteEmailReminder_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// EmailReminderServiceServer is the server API for EmailReminderService service.
// All implementations must embed UnimplementedEmailReminderServiceServer
// for forward compatibility.
type EmailReminderServiceServer interface {
	GetEmailReminder(context.Context, *EmailReminderIDIn) (*EmailReminderResponse, error)
	SearchEmailReminder(context.Context, *EmailReminder) (*EmailReminderRepeatResponse, error)
	CreateEmailReminder(context.Context, *EmailReminder) (*EmailReminderResponse, error)
	UpdateEmailReminder(context.Context, *EmailReminder) (*Result, error)
	DeleteEmailReminder(context.Context, *EmailReminderIDIn) (*Result, error)
	mustEmbedUnimplementedEmailReminderServiceServer()
}

// UnimplementedEmailReminderServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedEmailReminderServiceServer struct{}

func (UnimplementedEmailReminderServiceServer) GetEmailReminder(context.Context, *EmailReminderIDIn) (*EmailReminderResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetEmailReminder not implemented")
}
func (UnimplementedEmailReminderServiceServer) SearchEmailReminder(context.Context, *EmailReminder) (*EmailReminderRepeatResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SearchEmailReminder not implemented")
}
func (UnimplementedEmailReminderServiceServer) CreateEmailReminder(context.Context, *EmailReminder) (*EmailReminderResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateEmailReminder not implemented")
}
func (UnimplementedEmailReminderServiceServer) UpdateEmailReminder(context.Context, *EmailReminder) (*Result, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateEmailReminder not implemented")
}
func (UnimplementedEmailReminderServiceServer) DeleteEmailReminder(context.Context, *EmailReminderIDIn) (*Result, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteEmailReminder not implemented")
}
func (UnimplementedEmailReminderServiceServer) mustEmbedUnimplementedEmailReminderServiceServer() {}
func (UnimplementedEmailReminderServiceServer) testEmbeddedByValue()                              {}

// UnsafeEmailReminderServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to EmailReminderServiceServer will
// result in compilation errors.
type UnsafeEmailReminderServiceServer interface {
	mustEmbedUnimplementedEmailReminderServiceServer()
}

func RegisterEmailReminderServiceServer(s grpc.ServiceRegistrar, srv EmailReminderServiceServer) {
	// If the following call pancis, it indicates UnimplementedEmailReminderServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&EmailReminderService_ServiceDesc, srv)
}

func _EmailReminderService_GetEmailReminder_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EmailReminderIDIn)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EmailReminderServiceServer).GetEmailReminder(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EmailReminderService_GetEmailReminder_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EmailReminderServiceServer).GetEmailReminder(ctx, req.(*EmailReminderIDIn))
	}
	return interceptor(ctx, in, info, handler)
}

func _EmailReminderService_SearchEmailReminder_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EmailReminder)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EmailReminderServiceServer).SearchEmailReminder(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EmailReminderService_SearchEmailReminder_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EmailReminderServiceServer).SearchEmailReminder(ctx, req.(*EmailReminder))
	}
	return interceptor(ctx, in, info, handler)
}

func _EmailReminderService_CreateEmailReminder_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EmailReminder)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EmailReminderServiceServer).CreateEmailReminder(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EmailReminderService_CreateEmailReminder_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EmailReminderServiceServer).CreateEmailReminder(ctx, req.(*EmailReminder))
	}
	return interceptor(ctx, in, info, handler)
}

func _EmailReminderService_UpdateEmailReminder_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EmailReminder)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EmailReminderServiceServer).UpdateEmailReminder(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EmailReminderService_UpdateEmailReminder_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EmailReminderServiceServer).UpdateEmailReminder(ctx, req.(*EmailReminder))
	}
	return interceptor(ctx, in, info, handler)
}

func _EmailReminderService_DeleteEmailReminder_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EmailReminderIDIn)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EmailReminderServiceServer).DeleteEmailReminder(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EmailReminderService_DeleteEmailReminder_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EmailReminderServiceServer).DeleteEmailReminder(ctx, req.(*EmailReminderIDIn))
	}
	return interceptor(ctx, in, info, handler)
}

// EmailReminderService_ServiceDesc is the grpc.ServiceDesc for EmailReminderService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var EmailReminderService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "proto.EmailReminderService",
	HandlerType: (*EmailReminderServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetEmailReminder",
			Handler:    _EmailReminderService_GetEmailReminder_Handler,
		},
		{
			MethodName: "SearchEmailReminder",
			Handler:    _EmailReminderService_SearchEmailReminder_Handler,
		},
		{
			MethodName: "CreateEmailReminder",
			Handler:    _EmailReminderService_CreateEmailReminder_Handler,
		},
		{
			MethodName: "UpdateEmailReminder",
			Handler:    _EmailReminderService_UpdateEmailReminder_Handler,
		},
		{
			MethodName: "DeleteEmailReminder",
			Handler:    _EmailReminderService_DeleteEmailReminder_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "pkg/proto/tithe-declare.proto",
}
